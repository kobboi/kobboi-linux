From 259b565eb1691203efdf828723f01aff8b3338ea Mon Sep 17 00:00:00 2001
From: Manuel Stoeckl <code@mstoeckl.com>
Date: Sat, 25 Sep 2021 22:34:44 -0400
Subject: [PATCH] Dynamically resize connection buffers

Both data and fd buffers are resized on demand.

Signed-off-by: Manuel Stoeckl <code@mstoeckl.com>
---
 src/connection.c | 143 ++++++++++++++++++++++++++++++++---------------
 1 file changed, 99 insertions(+), 44 deletions(-)

diff --git a/src/connection.c b/src/connection.c
index 98f503b9..07d45e83 100644
--- a/src/connection.c
+++ b/src/connection.c
@@ -55,12 +55,11 @@ div_roundup(uint32_t n, size_t a)
 }
 
 struct wl_ring_buffer {
-	char data[4096];
+	char* data;
 	uint32_t head, tail;
+	uint32_t size_bits;
 };
 
-#define MASK(i) ((i) & 4095)
-
 #define MAX_FDS_OUT	28
 #define CLEN		(CMSG_LEN(MAX_FDS_OUT * sizeof(int32_t)))
 
@@ -71,23 +70,34 @@ struct wl_connection {
 	int want_flush;
 };
 
+static size_t
+ring_buffer_space(const struct wl_ring_buffer *b) {
+	return ((size_t)1) << b->size_bits;
+}
+
+static uint32_t
+ring_buffer_mask(const struct wl_ring_buffer *b, uint32_t i) {
+	uint32_t m = (((uint32_t)1) << b->size_bits) - 1;
+	return i & m;
+}
+
 static int
 ring_buffer_put(struct wl_ring_buffer *b, const void *data, size_t count)
 {
 	uint32_t head, size;
 
-	if (count > sizeof(b->data)) {
+	if (count > ring_buffer_space(b)) {
 		wl_log("Data too big for buffer (%d > %d).\n",
-		       count, sizeof(b->data));
+		       count, ring_buffer_space(b));
 		errno = E2BIG;
 		return -1;
 	}
 
-	head = MASK(b->head);
-	if (head + count <= sizeof b->data) {
+	head = ring_buffer_mask(b, b->head);
+	if (head + count <= ring_buffer_space(b)) {
 		memcpy(b->data + head, data, count);
 	} else {
-		size = sizeof b->data - head;
+		size = ring_buffer_space(b) - head;
 		memcpy(b->data + head, data, size);
 		memcpy(b->data, (const char *) data + size, count - size);
 	}
@@ -102,19 +112,19 @@ ring_buffer_put_iov(struct wl_ring_buffer *b, struct iovec *iov, int *count)
 {
 	uint32_t head, tail;
 
-	head = MASK(b->head);
-	tail = MASK(b->tail);
+	head = ring_buffer_mask(b, b->head);
+	tail = ring_buffer_mask(b, b->tail);
 	if (head < tail) {
 		iov[0].iov_base = b->data + head;
 		iov[0].iov_len = tail - head;
 		*count = 1;
 	} else if (tail == 0) {
 		iov[0].iov_base = b->data + head;
-		iov[0].iov_len = sizeof b->data - head;
+		iov[0].iov_len = ring_buffer_space(b) - head;
 		*count = 1;
 	} else {
 		iov[0].iov_base = b->data + head;
-		iov[0].iov_len = sizeof b->data - head;
+		iov[0].iov_len = ring_buffer_space(b) - head;
 		iov[1].iov_base = b->data;
 		iov[1].iov_len = tail;
 		*count = 2;
@@ -126,19 +136,19 @@ ring_buffer_get_iov(struct wl_ring_buffer *b, struct iovec *iov, int *count)
 {
 	uint32_t head, tail;
 
-	head = MASK(b->head);
-	tail = MASK(b->tail);
+	head = ring_buffer_mask(b, b->head);
+	tail = ring_buffer_mask(b, b->tail);
 	if (tail < head) {
 		iov[0].iov_base = b->data + tail;
 		iov[0].iov_len = head - tail;
 		*count = 1;
 	} else if (head == 0) {
 		iov[0].iov_base = b->data + tail;
-		iov[0].iov_len = sizeof b->data - tail;
+		iov[0].iov_len = ring_buffer_space(b) - tail;
 		*count = 1;
 	} else {
 		iov[0].iov_base = b->data + tail;
-		iov[0].iov_len = sizeof b->data - tail;
+		iov[0].iov_len = ring_buffer_space(b) - tail;
 		iov[1].iov_base = b->data;
 		iov[1].iov_len = head;
 		*count = 2;
@@ -150,11 +160,11 @@ ring_buffer_copy(struct wl_ring_buffer *b, void *data, size_t count)
 {
 	uint32_t tail, size;
 
-	tail = MASK(b->tail);
-	if (tail + count <= sizeof b->data) {
+	tail = ring_buffer_mask(b, b->tail);
+	if (tail + count <= ring_buffer_space(b)) {
 		memcpy(data, b->data + tail, count);
 	} else {
-		size = sizeof b->data - tail;
+		size = ring_buffer_space(b) - tail;
 		memcpy(data, b->data + tail, size);
 		memcpy((char *) data + size, b->data, count - size);
 	}
@@ -166,6 +176,36 @@ ring_buffer_size(struct wl_ring_buffer *b)
 	return b->head - b->tail;
 }
 
+static int
+ring_buffer_ensure_space(struct wl_ring_buffer *b, size_t extra) {
+	size_t net_size = ring_buffer_size(b) + extra;
+	size_t size_bits = b->size_bits;
+	/* Shrink if buffer is much larger than necessary.*/
+	size_t min_size = 12;
+	while (size_bits > min_size && net_size < (((size_t)1) << (size_bits - 3))) {
+		size_bits--;
+	}
+	/* Expand to ensure buffer is large enough */
+	while (net_size > (((size_t)1) << size_bits)) {
+		size_bits++;
+	}
+	if (size_bits == b->size_bits) {
+		return 0;
+	}
+	char *new_data = calloc( ((size_t)1) << size_bits, 1);
+	if (!new_data) {
+		errno = ENOMEM;
+		return -1;
+	}
+	ring_buffer_copy(b, new_data, ring_buffer_size(b));
+	free(b->data);
+	b->data = new_data;
+	b->size_bits = size_bits;
+	b->head = ring_buffer_size(b);
+	b->tail = 0;
+	return 0;
+}
+
 struct wl_connection *
 wl_connection_create(int fd)
 {
@@ -175,6 +215,16 @@ wl_connection_create(int fd)
 	if (connection == NULL)
 		return NULL;
 
+	size_t default_bits = 12;
+	connection->fds_in.size_bits = default_bits;
+	connection->fds_out.size_bits = default_bits;
+	connection->in.size_bits = default_bits;
+	connection->out.size_bits = default_bits;
+	connection->fds_in.data = calloc(1, 1 << connection->fds_in.size_bits);
+	connection->fds_out.data = calloc(1, 1 << connection->fds_out.size_bits);
+	connection->in.data = calloc(1, 1 << connection->in.size_bits);
+	connection->out.data = calloc(1, 1 << connection->out.size_bits);
+
 	connection->fd = fd;
 
 	return connection;
@@ -183,13 +233,14 @@ wl_connection_create(int fd)
 static void
 close_fds(struct wl_ring_buffer *buffer, int max)
 {
-	int32_t fds[sizeof(buffer->data) / sizeof(int32_t)], i, count;
+	int32_t i, count;
 	size_t size;
 
 	size = ring_buffer_size(buffer);
 	if (size == 0)
 		return;
 
+	int32_t *fds = calloc(size / sizeof(int32_t), sizeof(int32_t));
 	ring_buffer_copy(buffer, fds, size);
 	count = size / sizeof fds[0];
 	if (max > 0 && max < count)
@@ -198,6 +249,7 @@ close_fds(struct wl_ring_buffer *buffer, int max)
 	for (i = 0; i < count; i++)
 		close(fds[i]);
 	buffer->tail += size;
+	free(fds);
 }
 
 void
@@ -213,6 +265,10 @@ wl_connection_destroy(struct wl_connection *connection)
 
 	close_fds(&connection->fds_out, -1);
 	close_fds(&connection->fds_in, -1);
+	free(connection->fds_in.data);
+	free(connection->fds_out.data);
+	free(connection->in.data);
+	free(connection->out.data);
 	free(connection);
 
 	return fd;
@@ -256,7 +312,7 @@ static int
 decode_cmsg(struct wl_ring_buffer *buffer, struct msghdr *msg)
 {
 	struct cmsghdr *cmsg;
-	size_t size, max, i;
+	size_t size, i;
 	int overflow = 0;
 
 	for (cmsg = CMSG_FIRSTHDR(msg); cmsg != NULL;
@@ -266,8 +322,8 @@ decode_cmsg(struct wl_ring_buffer *buffer, struct msghdr *msg)
 			continue;
 
 		size = cmsg->cmsg_len - CMSG_LEN(0);
-		max = sizeof(buffer->data) - ring_buffer_size(buffer);
-		if (size > max || overflow) {
+
+		if (ring_buffer_ensure_space(buffer, size) < 0 || overflow) {
 			overflow = 1;
 			size /= sizeof(int32_t);
 			for (i = 0; i < size; i++)
@@ -299,10 +355,21 @@ wl_connection_flush(struct wl_connection *connection)
 
 	tail = connection->out.tail;
 	while (connection->out.head - connection->out.tail > 0) {
-		ring_buffer_get_iov(&connection->out, iov, &count);
-
 		build_cmsg(&connection->fds_out, cmsg, &clen);
 
+		if (clen >= CMSG_LEN(MAX_FDS_OUT * sizeof(int32_t))) {
+			/* Send only a single byte, to ensure all FDs are sent
+			 * before the bytes are cleared out. This can fail to
+			 * clear the FDs first if individual messages are allowed to
+			 * have 8*28 = 224 fds. */
+			iov[0].iov_base = connection->out.data +
+				ring_buffer_mask(&connection->out, connection->out.tail);
+			iov[0].iov_len = 1;
+			count = 1;
+		} else {
+			ring_buffer_get_iov(&connection->out, iov, &count);
+		}
+
 		msg.msg_name = NULL;
 		msg.msg_namelen = 0;
 		msg.msg_iov = iov;
@@ -343,8 +410,7 @@ wl_connection_read(struct wl_connection *connection)
 	char cmsg[CLEN];
 	int len, count, ret;
 
-	if (ring_buffer_size(&connection->in) >= sizeof(connection->in.data)) {
-		errno = EOVERFLOW;
+	if (ring_buffer_ensure_space(&connection->in, 1) < 0) {
 		return -1;
 	}
 
@@ -378,12 +444,8 @@ int
 wl_connection_write(struct wl_connection *connection,
 		    const void *data, size_t count)
 {
-	if (connection->out.head - connection->out.tail +
-	    count > ARRAY_LENGTH(connection->out.data)) {
-		connection->want_flush = 1;
-		if (wl_connection_flush(connection) < 0)
-			return -1;
-	}
+	if (ring_buffer_ensure_space(&connection->out, count) < 0)
+		return -1;
 
 	if (ring_buffer_put(&connection->out, data, count) < 0)
 		return -1;
@@ -397,12 +459,8 @@ int
 wl_connection_queue(struct wl_connection *connection,
 		    const void *data, size_t count)
 {
-	if (connection->out.head - connection->out.tail +
-	    count > ARRAY_LENGTH(connection->out.data)) {
-		connection->want_flush = 1;
-		if (wl_connection_flush(connection) < 0)
-			return -1;
-	}
+	if (ring_buffer_ensure_space(&connection->out, count) < 0)
+		return -1;
 
 	return ring_buffer_put(&connection->out, data, count);
 }
@@ -429,11 +487,8 @@ wl_connection_get_fd(struct wl_connection *connection)
 static int
 wl_connection_put_fd(struct wl_connection *connection, int32_t fd)
 {
-	if (ring_buffer_size(&connection->fds_out) == MAX_FDS_OUT * sizeof fd) {
-		connection->want_flush = 1;
-		if (wl_connection_flush(connection) < 0)
-			return -1;
-	}
+	if (ring_buffer_ensure_space(&connection->fds_out, sizeof fd) < 0)
+		return -1;
 
 	return ring_buffer_put(&connection->fds_out, &fd, sizeof fd);
 }
-- 
GitLab

